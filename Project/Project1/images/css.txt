CSS
Cascading Style Sheets의 약자로 마크업 언어(HTML/XHTML)가 실제 화면에 표시되는 방법(디자인)을 기술하는 언어.
즉, HTML문서의 레이아웃과 스타일을 정의한다.
파일형식은 '*.css'로 저장.


*css 기본 구조
Selector선택자 { Property 특성 : Value 값; }
; 세미콜론은 마지막에  그 선택자의 끝을 알리는 표시임. 선택자가 끝나면 필수로 끝마쳐줘야함.


*css 주석처리
 /* 스타일 태그 내부는 css영역 */


*css 함수
-calc();
 다른 단위 값들끼리 연산이 가능 (+, -, /, *)
 연산자 사이에는 반드시 띄어쓰기 필요
   width:calc(16.6666% - 1vw);
-attr();
  html의 속성을 가져옴
  content: attr(data-txt);  (data-txt=" "   data- : 사용자 정의 속성: 내가 만든 속성)



**Style태그 

*글자색변경 color
외부 선언 : css 문서를 따로 만들어 그파일에서 컬러변경 후  head부분에 <link rel="stylesheet" href="위치,문서명.css"> 로 연결
내부 선언 : <head> 안에 <style>를 사용하여 작성
<head>
 <style>
    h2{color:red;}
 </style>
</head>
외부 선언 : <a href="#" style="특성 값">으로 작성
  -color특성
color name: orange
hex; #FF5F00
rgb: rgb(0,55,150)
rgba(red,green,blue,alpha): rgba(50,100,250,0.7) 마지막 자리수는 불투명도로 0~1사이의 값을 가짐.(alpha:투명도,소숫점으로 표기)
hsla(색상,채도%,명도%,불투명도): %를 붙여 사용

*text-indent: -9999px; 
글자 안보이게

*word-break: break-all;
(한글기준) 단어를 기준으로 줄바꿈

*overflow-wrap: break-word;
(영문기준) 의미가 없는 텍스트 줄바꿈을 설정

* 한 줄 말줄임 상황
  text-overflow: ellipsis; 말줄임
  white-space: nowrap; 자동 줄바꿈 금지 

*여러 줄 말줄임 
  display: -webkit-box;
  text-overflow: ellipsis;
  word-break: break-word;
  -webkit-line-clamp: 2; 

* 여러 줄 텍스트 자르기
  -webkit-box-orient: vertical;

*CSS상속 inheritance
해당 선택자의 자식, 자손까지 같은 특성이 적용되는 것.
주로 서체와 관련된 특성들이 상속되는 경우가 많음
ex)
타입선택자 : body
자식 : dl
자손 : dt(body의 자손)
선택자는 우선순위가 있음
부모 및 조상의 상속 값은 본인(자식)의 적용 값보다 우선하지 않는다.
즉 직접 적용 값이 우선.
같은 특성 적용시 선택자의 우선 순위가 높은 선택자 특성이 적용.
타입 선택자보다 아이디 선택자가 우선적으로 적용.
--------------------------------------
*타입선택자
 section, body, p, h, 등

*id 선택자
하나의 html문서 안에서 고유한 이름을 가지면 다른 id에 같은 이름을 쓸 수 없음
ex)  <p id="yeji1"></p>
       #yeji1{color:red}	
그 부분에만 색깔을 변경하고싶을때 등 사용
#id id네임앞에 # 을 붙여줌

*class 선택자
한 문서 안에서 같은 이름을 여러번 사용할 수 있기 때문에 주로 꾸밈 값을 줄 때나 공통된 값 적용시 사용
class네임 앞에 . 을 붙여줌
<p class="yeji1"></p>
.yeji1{background color: red;}
---------------------------------------
html에서, class="box bg1"은 .box .bg1을 적용하겠다는 의미.
여러개의 클래스선택자 적용시 띄어쓰기로 구분, class속성만 해당되며 id속성은 띄어쓰기 안됨.


*배경색변경 background color
color적용과 동일 방
   h1{color: aqua;
       background-color:#efefef;}

*CSS 우선 순위
-같은 이름 혹은 종류의 선택자인 경우
  =같은 특성이 적용된 경우 아래쪽에 작성된 값이 우선 적용
 (내부) h1{color:lightcoral
      color:blue}
  -> 즉  h1에 blue컬러가 적용됨. 
 (외부)#box (id="box"를 style1.css시트와 style2.css 시트에 동시에 적었을경우)
<link rel="stylesheet" href="style1.css">
<link rel="stylesheet" href="style2.css">
  ->style2시트에 적은값이 적용됨
<link rel="stylesheet" href="style2.css">
<link rel="stylesheet" href="style1.css">
 ->style1시트에 적은값이 적용됨

-같은 선택자가 아닌 다른 종류 선택자인 경우
  =(직접, inline >) #id(5) > class(3) > type(1) 순으로 우선 순위를 갖는다.
!important : 기본 우선순위가 무시되며 무조건 적용, 꼭 필요한 경우에만 주의해서 작성(거의안씀)
{background-color: #e0b1cb !important;}

-다른 종류의 선언문이며 같은 선택자인 경우
  =(직접, inline >) 내부선언 > 외부선언 순으로 우선 순위를 갖는다.


*visual studio Code html기본 설정법
 -카페에있음


*font와 text의 여러 특성들
font-family: 서체 종류 (첫번째 서체가 없을 경우를 대비해 2가지를 써줌  font-family: '휴먼둥근헤드라인','맑은 고딕', sans-serif;)
font-size: 서체 크기(*웹브라우저 기본서체크기 16px)
font-weight: 서체 굵기(nomal:400 / bold(기본) / extrabold(100-900) /서체가 굵기를 지원해주어야 가능)
font-style: 서체 스타일(기울기 등. inherit;상속 보통normal을 많이씀)
text-transform: 대소문자(lowercase:소문자 / uppercase:대문자 / capitalize:단어의첫글자만대문자)
text-decoration: 밑줄 및 취소선(line-through:취소선 / underline:밑줄 /  text-underline-offset: 10px:밑줄행간 / none:밑줄삭제(a태그 링크밑줄지울때 많이 쓰임)
text-align: 서체 및 인라인 정렬(left/center/right/justify:양끝기준정렬.문단의양끝을 일렬로 맞추고 맨 마지막줄만 왼쪽으로 정렬)
text-indent: 들여쓰기 / 내쓰기(100px:들여쓰기 / -100px:내쓰기.마이너스를붙여준다)
text-shadow: 서체 그림자
   (text-shadow: 10px 10px 10px #999; /x축, y축, 번짐, 색상 / -10px -10px 10 #999 : 윗방향,왼쪽방향,번짐은-값못씀
   색상값을 안쓰면 글자색 따라감. 번짐은 0이나 생략하면 번짐없어짐. 세미콜론찍지않고 ,찍고 계속 쓰면 중첩그림자 가능)
line-height: 줄과 줄 사이 간격. 행간(자주쓰임. 숫자로만 표현한 1.7이면 행간은 폰트크기의 1.7배. 단위값(px등)은 잘 쓰지 않음 .상속가능. 인라인 요소의 위 아래 여백을 만들 수 있으나 그목적으로는 잘 사용하지 않음. )
letter-spacing: 글자와 글자 사이 간격. 자간
word-spacing: 단어와 단어 사이 간격. 어간
cursor : 마우스커서모양 바꿈 (pointer:손가락모양)
*서체 주의사항
1. 정확한 서체명 작성(띄어쓰기, 인용부호, 대소문자 등)
2. 상대방의 컴퓨터에 서체가 없는 경우를 대비해 3~4개 서체를 추가 작성(fallback fonts)
3. 바탕체 종류로 끝나는 경우 제일 마지막은 serif로 작성
4. 돋움(고딕)체로 끝나는 경우 제일 마지막은 sans-serif로 작성
( font-family: '휴먼둥근헤드라인','맑은 고딕', sans-serif;)
5. font속성의 경우 폼 관련 요소에 직접 사용


*서체(글꼴) 종류. 상속
 -자식의 배경색상이 없을땐 상속된것 처럼 보이나 배경색은 상속 되지 않음.
 -글꼴,색상,크기 상속


*자식찾아가기
 #text1 > .text1 > span{(ex)color:balck}
이런식으로 >를 사용하고 순차적으로 내려갈 수 있음.



* :  :: 가상선택자
가상 선택자로 다양한 종류가 있으며 주로 실제하는 요소와 함께 작성
:link(링크상태일때 기본), :visited(마우스로 방문했을 때), :hover(마우스를 위에 올렸을 때), :active(마우스로 클릭했을때), :checked(체크박스에 체크가 되면),:disabled(비활성)
 h1::selection{background-color: orange;} ->   h1::selection - h1을 드래그 했을 때.  드래그색깔을 오렌지색으로 함
    ::selection{} -> 문서 전체
우선순위 적용 안됨. 겹치는 부분이 우선적으로 적용됨


*인접형제 선택자 '+'
기준요소 바로 뒤에 오는 형제 관계 선택자
인접해 있는 두 개의 동등한 위치(형제관계)에 있는 뒤쪽 선택자에 적용
딱 하나만 적용 가능.

*일반형제 선택자 '~'
기준요소 뒤에 오는 모든 형제 관계 선택자
 ex ))) table.box2 ~ table td (.box2 뒤에 오는 모든 형제 관계의 table의 하위로 있는 td)


*종속선택자 '.'
띄어쓰기 없이 작성.(자식,자손이 아님)
main.h3.classname2
 =h3요소가 가진 클래스 중에 classname2 값을 가진 요소 탐색


*특성선택자
 요소[특성="값"] 특성 선택자: input요소들 중에 type의 값이 text인 선택자
 form > fieldset > input[type=["text"]{color: orange;}


*전체 선택자 '*'
 html문서 안의 모든 요소에 직접 적용 


*다중선택자 ','
여러 선택자에 동일한 특성을 부여하고자 할 때 사용. 쉼표로 구 분, 띄어쓰기 상관 없음


*vertical-align(인라인요소)
인라인 세로 정렬 
영어기준
서체 및 인라인 요소 세로 정렬 기준
table안에서도 사용 됨
글씨와 이미지 및 input의 정렬 상태가 맞지 않는다면, 이미지 요소 및 input에 vertical-align 적용
top : 현재 요소와 자손들 모두 top 기준
baseline : 기본값(이미지하단에 여백생김. 이미지도적용)
bottom : 현재 요소와 자손들 모두 bottom 기준
middle : 부모 기준 (baseline 기준으로 글자 높이의 반)


* width, height
    블록요소: p, div, h1, header, main, article, form, ul...
                ㄴ가로값의 경우 부모 요소의 가로 값을 받음
                ㄴ일반적인 흐름에서는 블록 요소 옆에 다른 요소가 올 수 없음
                ㄴ자식으로 블록, 인라인 요소 등 대부분이 올수 있음
                ㄴ세로 값의 경우 자식 요소의 높이 값을 가져옴
                ㄴwidth, height로 제어 가능 
  인라인요소: span, img, a, em, input, strong...
                 ㄴ가로 값의 경우 자식(컨텐츠)의값을 가져옴
                 ㄴ인라인 요소 옆에 다른 인라인 요소가 올 수 있음
                 ㄴ자식으로 인라인 요소만 올 수 있음
                 ㄴ세로 값의 경우 자식 요소의 높이 값을 가져 옴
                 ㄴwidth, height로 제어 불가능     
고정너비 : width: 500px; height: 300px;
가변너비 : width: 70%;  %:부모를 기준으로 100분의 70(모니터의화면의크기때문에 가로는정해져있음)
	height: 50%;  세로%는 부모의 높이 값이 정의되어 있는 경우에만 적용됨(스크롤이 무한정임)
		      (body, html에 height:100%주거나 vh단위를 쓰면 해결 가능)

table에서 사용시: 각각의 셀들에게 개별적으롤 제어하지 못하며 셀 안의 콘텐츠 크기에 의해 크기가 정해짐.
전체 사이즈는 1000을 넘지 않음.

max-width : 최대 가로값이 어떤 값 이상 커지지 않음
min-width: 최소 가로값이 어떤 값 이상 작아지지 않음


*border 테두리
<테두리굵기>
border-top-width: 4px;
border-bottom-width: 1px;
border-right-width: 2px;
border-left-width: 10px;
<테두리스타일>
border-right-style: solid; (실선)
border-bottom-style: dashed; (자른선)
border-top-style: dotted; (점선)
border-left-style: double; (이중선. 3px 이상에서만 보임)
<테두리색상>
border-top-color: color,rgb ;
border-right-color:;
border-left-color:;
border-bottom-color:; 
<테두리 네 방향의 값이 같을 때>
border-style: groove; (입체선)
border-width: 10px;
border-color: red;
(축약형)
border: 8px solid #7149c6; (값의 순서의 상관없이 띄어쓰기로 구분)
outline : 박스테두리. border와 달리 요소의 실제 크기에 영향을 주지 않음.(계산불가)
<둥근모서리>
border을 먼저 설정 해 주고
border-radius: 30px : 모서리4개 전부 30만큼 둥글게
border-radius: 100px 50px 20px 100px; : top-left / top-right / bottom-right / bottom-left 순서
border-radius: 50% : width,height의 절반만큼 적용. 원을 만들 수 잇음
transparent : 투명


* outline:none;
크롬,엣지,웨일 등 모던 브라우저에서 생기는 현상으로 포커스 상태일 때 테두리 없앰


*padding 기준요소 안쪽 여백
padding-top: 20px;
padding-right: 30px;
padding-bottom: 30px;
padding-left: 50px;
텍스트 공간의 여백이 생김
padding:30px; (4면의여백을 30px으로 통일)
padding: 50px 30px 20px 10px; (시계방향으로 각각 적용 ->이순서는고정값)

*margin 기준요소 바깥 여백 
div를 사용해야 함.
padding과 사용법은 같음.

마진 상쇄 현상 : margin-bottom과margin-top의 여백은 합쳐지지 않고 둘중 더 큰 여백이 적용 됨.
단 float, flex, overflow, position 등의 값이 적용 된 경우는 발생하지 않음.
형제 관계 요소의 margin-bottom과 margin-top이 만나면 둘 중 큰 값이 적용.
부모 자식 관계 요소에서 margin-top의 값이 같이 들어간 경우 둘 중 큰 값이 적용.
일반적인 흐름에서, 자식의 margin-top과 부모의 margin-top이 만나면 둘 중 큰 값이 부모에게 적용
(해결방법 : 부모 요소에 overflow:hidden; 적용)

블록요소의 중앙 정렬(text-align은 인라인)
margin: 0 auto 0 auto (top right bottom left)
-요소의 가로 값 필요
-일반적인 흐름
-auto : 가로만 중앙정렬. 세로는 적용 안됨.


*overflow 넘치는 컨텐츠 제어
width, height 값이 정해져 있어야 overflow 적용 가능.
overflow: inherit; 상속-원래 현재 부모나 조상요소에 overflow가 적용된 게 없으면 상속 받지 못함.
overflow: visible;  컨텐츠가넘쳐도 무조건 보임.(기본값)
overflow: hidden; 컨텐츠가 넘칠때 무조건 숨김.
overflow: auto; 컨텐츠가 넘치면 세로스크롤이 생김. 안넘치면 기본값.
overflow: scroll; 컨텐츠가 넘치지 않아도 가로,세로스크롤이 생김.
overflow-y: 상위명령;  y축에서만 적용
overflow-x
white-space: wrap; 글자의 띄어쓰기 기준으로 줄바꿈 처리(기본값)
white-space: nowrap: br요소로 줄바꿈 시키는 것 외엔 자동 줄바꿈 되지 않음.


*opacity 투명도
opacity: 0.4; 투명도40%


*요소의 기본성격 변경 (상속X, 해당요소에만 적용)
display: inline;  ->블록에서 인라인성격으로 변함(띄어쓰기의영향을받아 잘사용하지는않음)
display: inline-block; ->인라인,블록 성격 둘다 가짐. <인라인처럼 띄어쓰기,줄바꿈인식/
인라인처럼 line-height값을 가짐/블록처럼 width, height 값을 가짐/가로 중앙 정렬의 경우 인라인, 블록 적용 방식 둘다 가능. 다만, 띄어쓰기가 있어 인라인 방식으로 정렬하는 것이 좀 더 편함.>
display: none; 브라우저 영역에서 사라짐. 코드 창에서만 확인 가능하며 레이아웃에 영향을 줌.
visibility: hidden; 브라우저 영역은 남으나 컨텐츠가 보이지 않음. visible 보임, hidden 숨김. 
opacity: 불투명도 조절. 자식에게 영향줌


*box shadow 박스그림자
.box1{ box-shadow: 10px 10px 10px 10px black;} (x축 y축 번짐 확장거리 색상) 
번짐 생략 가능
box-shadow:10px 10px 10px gold, -10px -10px 10px orange; 중첩 가능
box-shadow:0 0 30px green inset; 내부그림자


*요소의 실제 크기
너비 :width + margin-left + margin-right + padding-left + padding-right + border-left + border-right
높이:height + margin-top + margin-bottom + padding-top + padding-bottom + border-top + border-bottom
outline, auto는 0으로 생각하기(auto는 중앙정렬이라 정확한값을 모르기 때문)


*어절기준 줄바꿈 제어 
word-break: normal; 
word-break: break-all;  어절에 맞춰 줄바꿈. 영어 한정
word-break: keep-all;   어절을 유지하며 줄바꿈. 한글 적용


*요소의 실제크기 계산 방식 설정. box-sizing
상속x
box-sizing: content-box;  기본값. width+margin+padding+border
box-sizing: border-box;  width(padding+border)+margin
 margin은 box-sizing에 들어가지 않음.


*list style 변경
list-style-type: disc;  -> ●
list-style-type: upper-alpha; ->대문자
list-style-type: upper-roman; ->로마자 
list-style-type: decimal-leading-zero; -> 01. 02. 03 등.
ol, ul 둘다 변경 가능.


*머리말 기호 위치 list style position 변경
list-style-position: outside; (문단 바깥. 기본값)
list-style-position: inside; (문단 안쪽)


*list style 축약형
list-style: inside lower-roman; 띄어쓰기로 구분.
list style: none; 주로 메뉴를 만들 때 사용. 가장 많이 사용.
    

*table style
empty-cells: show; (셀 남김. 기본값)
empty-cells: hide; (셀 숨김)
border-spacing: 20px 50px; (셀과 셀 사이의 간격. table 요소에만 해당. x축 y축)
border-collapse: separate; (기본값. 겹치는 셀 테두리 값 그대로 둠. (1px 1px 겹치면 2px이 되는걸 그대로 둠)
border-collapse: collapse; (겹치는 셀 테두리의 간격을 없애 한줄로 겹치게 함.)


*accent-color
: input type= checkbox, radio, range, progress 이 네가지만 컨트롤 값 제어

   form fieldset input[type=radio]{
   accent-color: palevioletred;}
-> radio 선택 o칸의 색상 변경

    form fieldset progress[value]{
    accent-color: palevioletred;}
-> 바 색상 변경

    form fieldset input[type=range]{
    accent-color: palevioletred;}
-> 움직이는 바 색상 변경


*position 요소의 배치
 ㄴstatic; 
     	기본값; 아무런 특성이 없기 때문에 주로 다른 포지션 값이 적용된 요소를 초기화 하고자 할때 사용

 ㄴrelative; 
   	 일반적인 흐름에 따라 자기 자신을 기준으로 위치지정. top, right, bottom, left 위치 특성과 함께 사용되거	             나 생략 될 수 있음.(원래 있던 위치를 기준으로 이동.)
	 x축(left,right) y축(top,bottom)위치값 작성시 하나의 방향값만 작성 가능.       
	 top,bottom 함께 작성시 top적용. left,right 함께 작성시 left 적용.)
     	 자식,형제 관계의 요소에 기준값을 적용해도 되지 않음.
     	 부모와 조상 요소 둘 다 포지션이 적용 된 경우 가까운 부모를 기준으로 적용.
	 relative를 기준으로 많이 사용하는 이유: 위치특성과(top,right,bottom,left)
	 함께 사용하지 않으면 기존 레이아웃에 영향을 주지 않기 때문에 많이 사용.
	 중앙정렬 : 위치 특성이 작성되어 있지 않으면 margin: 0 auto 가능.
	 *relative와 float를 동시에 적용시 float인식

 ㄴabsolute; 
 	일반적인 흐름에서 벗어나며 포지션이 적용된 가장 가까운 부모 요소를 기준으로 위치 지정. 
	top, right, bottom, left 위치 특성과 함께 사용.
	포지션이 적용된 가장 가까운 부모 요소를 기준으로 위치 지정.(반드시 부모이상의 요소에 적용)
  	일반적인 흐름에서 벗어나 다른 요소와 겹쳐짐. 포토샵 레이어처럼 층위를 만듦.
	기준 값을 설정해 주지 않으면 body를 기준으로 위치 설정.
	absolute 를 써주면 block요소로 바뀌기 때문에 width와 height값 적용 가능.

 ㄴfixed; 
	일반적인 흐름에서 벗어나며 브라우저를 기준으로 위치지정.
	top, right, bottom, left 위치 특성과 함께 사용.
             transform, perspective, filtere 특성이 부모 요소에 적용되어 있으면 그 요소를 기준으로 삼음.
	이값이 들어가면 height의 %가 인식됨.
	해당 요소를 감싸고 있는 부모, 조상 요소의 높이값을 100%로 설정. 
	(body:{height100%} html{height:100%} 작성.
	*fixed와 float를 동시에 적용시 fixed인식

 ㄴsticky; 일반적인 흐름을 가지나 top, right, bottom, left의 값에 따라 offset 적용(스크롤 이벤트)
	해당요소가 위치 특성 값이 지정한 곳에 도달하며 고정 위치의 포지션으로 성격이 바뀜.
         	부모요소들 중 하나라도  overflow:hidden이 적용되어 있으면 동작하지 않음.
        	 hieght값이 %로 설정 된 경우 동작하지 않음.
         	top, right, left, bottom중(고정할곳의위치) 반드시 하나만 작성 되어야 하며 작성하지 않으면 relative와 동일		한 성격을 가짐.
	부모 요소가 스크롤에 따라 화면 밖으로 넘어가면 함께 안보임.

-left:auto; 기존의 left 무력화 


 포지션중앙정렬
1.직접계산 (top:60px; left:160px;)
2.위치특성값 50%, 같은 방향의 margin값을 -요소의 반값 적용(top:50%; left:50%; margin-top:-40px; margin-left:-40%)
3. top:0; left:0; right:0; margin:auto;(높이값이 지정되어 있어야만 세로중앙정렬 가능)


*문서를 드래그 했을 때
::selection{bg,color 등 효과}


*내,외부 문서를 불러오는 방법
 @import url();


* 부드러운 스크롤
html{scroll-behavior: smooth;} 

*스크롤바 꾸미기
-스크롤바창 가로크기
body::-webkit-scrollbar{
width: 15px;}
-스크롤바창 색상  
body::-webkit-scrollbar-track{
background-color: #c6dde0; }
-스크롤바색상, 모양
body::-webkit-scrollbar-thumb{
background-color: #9fbbbf;
border-radius: 20px;;


*before, ::before
기준 요소 안의 컨텐츠 영역 앞쪽에 적용. 의사 요소
드래그 불가능.
p::before{content: :"설명";}  (content는 생략 불가능)

 ol .box2::before{
      content: "https://naver.com 주소:";
      background-color: blueviolet;
      padding-right: 10px;
      margin-right: 20px;}  --->이런식으로 링크,배경색,패딩,마진 등 추가 가능

*after, ::after
기준 요소 안의 컨텐츠 영역 뒤쪽에 적용.
p::after{content: ""; } (content특성 자체는 생략할수 없으나 ""안에 아무것도 작성하지 않는건 가능
}

content""; > 컨텐트 안에 값으로 작성되는 부분 ""은 텍스트 컨텐츠의 영역으로 코드값이 적용 안됨.
content"&lt;";   >X

<홈페이지 메뉴에 애프터 적용법>
(active가 붙으면 요소의 안쪽의 뒤에 적용)
a에 포지션을 주고 after로 사용.
java나 j쿼리로 class 이동하면서 클릭시 마다 옮겨가게 해줄 수 있음.

  .gnb li a{
   position:relative}

  .gnb li .active::after (class=active)
{
    content: "";
    width:100%;
    height: 4px;
    background-color:rgba(28, 57, 108, 0.8);
    position:absolute;
    left:0; right:0;
  }


*포지션 노출 순위 z-index
-요소에 포지션 값 적용시 포토샵의 레이어처럼 층 위의 개념이 생김. 이때 겹치는 순서를 정의.
-숫자가 클수록 위쪽에 위치. 단위값 없음. ( 9<99<999, 10<100<1000, 100<200<300 .. 1,2,3,4식으로 쓰지 않음)
-포지션이 적용되어 있어야만 사용 가능.
-flex, grid(포지션 외에 적용 가능)
-음수 값을 주면 제일 아래 배치 ( -1;)


*float (부유요소)
float: left; 왼쪽을 기준으로 요소 정렬. 진행방향이 왼쪽에서 오른쪽
float: right; 오른쪽을 기준으로 요소 정렬. 진행방향이 오른쪽에서 왼쪽
float값은 left, right만 있음.
위아래 요소를 나란히 두고 싶다면 둘 다 float값을 적용 시키면 됨.
상속되지 않음.
부유요소. 즉 떠있는 요소로 기존의 흐름에서 벗어남.
원래의 흐름에서 벗어났기 때문에 float가 적용되지 않은 다른 요소들이 float가 적용된 요소를 제외하고 순차적으로 정렬.
float가 적용된 요소는 떠 있기 때문에 부모의 가로값을 받지 못함. 컨텐츠가 가진 값을 기본으로 가짐. 
p{ float:left}
h1{float:left}
clear:both;  : float의 영향을 벗어나기 위해 사용.(다음줄로이동)->부모요소에 작성해야함.
	    기존의 float의 흐름에서 벗어나 새로운 흐름에서 시작.
	    float가 적용된 형제들 사이에서 단순 줄바꿈이 필요할 때 사용.
/* float와 position이 함께 적용 된 경우 position이 우선 적용 */

자식 요소에 float가 적용되면 부유 성격으로 인해 부모 요소는 높이값을 가지지 못함.
그럴때: 
부모 요소에 높이값 적용(권장x)
부모 요소에 float 적용
부모 요소에 overflow 적용(자식에게 float가 적용되면 부모의 높이 값이 인식되지 않기 때문에 부모 요소에 overflow 적용하여 높이값 인식)
부모 요소에 클리어픽스 핵 clearfix hack css 사용


*수열선택자, 의사클래스
:first-child{} 같은 부모를 둔 자식들 중 첫번째 자식
:last-child{} 같은 부모를 둔 자식들 중 마지막 자식
:nth-of-type(){} 같은 부모를 둔 자식들 중 n번째 자식

:first-of-type{}같은 부모를 둔 자식들 중 '같은타입'의 첫번째 자식
:last-of-type{}같은 부모를 둔 자식들 중 '같은타입'의 마지막 자식
:nth-of-type(){} 같은 부모를 둔 자식들 중 '같은타입'의 n번째 자식
:first-of-type ~p {}같은타입의 첫번째 자식 부터 모든 p 
(even) 짝수
(odd) 홀수
(3n+1)3개를 기준으로 첫번째
(3n)3번째

ex)
<div class=box>
 <p></p> 1,9
 <div></div> 3,7
 <div></div> 4,9
 <p></p> 5
 <div></div>9
 <p></p>
 <p></p>6,8,9
1 .box p:first-child{color:black} (같은 부모(class)를 둔 자식들 중 처음으로 나오는 요소가 p인 경우 글씨색 적용)
2 .box div:first-child{color:black;}(같은 부모를 둔 자식들 중에 처음 나오는 요소가 div가 아니기 때문에 글씨색 적용 x)
3 .boxr div:first-of-type{color:black;}(같은 부모를 둔 자식들 중 같은 타입의 첫번째 div에 적용)
4 .box div:last-of-type{background-color:blue;}(각 부모 안에서 같은 타입의 자식들 중 마지막 div에 적용)
5 .container p:last-child{background-color:blue}(가장 마지막에 나오는 자식이 p이기 때문에 배경색 적용)
6 .box p:nth-child(7){border: 5px solid white;}(자식들 중 7번째 위치에 p가 있기 때문에 테두리 적용)
7 .box div:nth-of-type(2){ color:rgb(152, 198, 244);}(자식들 중 같은 타입의 2번째 div)
8 .box p:nth-child(even){background color:red;}(짝수의 위치p들에게 각각 배경색 적용)
9 .box :nth-child(odd){font-style: italic;}(요소 구분 없이 홀수에 적용)
10 .box p:nth-child(3n+2){border-radius: 0;}(3개씩 기준으로 2번째 p에 적용)
11 .box p:nth-child(5n){border:3px solid black;}(5개씩 기준으로 5번째 p에 적용)
12 .box p:nth-of-type(4n+1){color:black}(같은 타입의 p중에 4개씩 기준으로 1번째 p에 적용)
13 .box :nth-child(n+3):nth-child(-n+11){color:black;;}(3~11까지 적용)


*flout와 sticky, fixed 같이쓸때
높이값이 지정이 안될 때에 overflow는 같이 쓸 수 없으니
    .clearfix::after{
      content: "";
      display: block;
      clear: both;
      height: 0;
      visibility: hidden;}
작성해줌.

img태그사용시 = object-fit, object-position  사용
backgroun-image태그 사용시 = background-position 사용

*사진,비디오 비율조정 object-fit
이미지<img>나 비디오 <video>의 비율 조정
object-fit: fill; (기본값. 비율 상관없이 가득 채움)
object-fit: contain; (비율 유지. 원본이 전부 보여짐. 대신 일부 여백이 생길 수 있음)
object-fit: cover; (비율 유지. 원본이 부모 영역을 가득 채우나 일부 가려지는 부분이 있을 수 있음)
object-fit: none; (원본 사이즈. 크기조절 x)
object-fit: scale-down; (none과 container 중 이미지 크기가 더 작아지는 값 선택)
*비디오는 이미지와 달리 원본 영상의 비율을 유지하기 때문에 width, height 값을 동시에 적용 시킬 수 없음
video 태그는 값이 적용되나 영상 자체의 비율은 영상 편집을 통해서만 가능.

*오브젝트 위치 정렬 object-position
이미지<img>나 비디오 <video>에 object-fit 적용 시 부모 요소를 기준으로 위치 정렬
object-position: 50% 50%; (기본값 x축 y축)
object-position: center center; (text도 가능)
object-position: 100px 50px; (가로세로)
object-position: 100% 50%; (100% =right center)
object-position: 20%; (x축만 20%. 한 축을 비워두면 똑같이 들어가는게 아닌 오브젝트 중심으로 들어감)


*배경이미지 background-image
body{ background-image: url(../images/pattern.gif);} 바디전체에 이미지를 넣음. 마진영역까지 적용(마진특징)
p{background-image: url(../images/pattern.gif);
padding:10px; } 배경이미지를 넣을 요소를 붙여주면 됨. 패딩값까지 사진 적용 가능.
이미지가 작아도 반복하는 성격 때문에 요소 전체에 넣어줄 수 있음.
img태그와 다르게 배경이기 때문에 드래그 안됨. 단독 사용 x


*배경이미지 반복 background-repeat
background-repeat: repeat; (반복, 기본값)
background-repeat: repeat-y; (y축으로 반복)
background-repeat: repeat-x; (x축으로 반복)
background-repeat: no-repeat; (반복 없음 이미지1개만나옴)


*배경이미지위치 background-position
background-position: 0 0; (기본값. x축 y축)
background-position: left top; (text로작성가능. 0 0;)
50% : 중앙
그외 : object-position과 동일.
브라우저 기준 위치가 아닌 요소의 기준에만 적용.
ex) body의 높이가 500px이라면 backgroun-position(0 100%);를 줫을 경우  y축을 100%으로 줬을 경우 아래 500px까지만 적용.


*배경이미지 고정 background-attachment
background-attachment: scroll; (기본값. 스크롤시 배경이미지도 함께 이동)
background-attachment: fixed; (viewport를 기준으로 배경이미지 고정. 배경이미지 한정 브라우저의 전체 높이가 인식됨.  브라우저를 기준으로 배경이미지를 고정하기 때문에 body의 높이값과 상관없이 위치 함)


*배경이미지 사이즈 background-size
background-size: 400px; (가로 사이즈를 기준으로 세로 사이즈 비율 자동 조절. px은 거의 안씀)
background-size: 100%; (가로 사이즈에 맞춰 조절되며 이미지의 비율도 유지. 화면에서 가려지는 부분 존재.)
background-size: 100% 100%; (전체로 꽉 차지만 요소를 기준으로 조절되기 때문에 이미지의 비율이 맞지 않음. 2자리는 잘 안씀)
background-size: contain; (영역에 맞춰 이미지 사이즈 조절. 공백이 생길 수 있으나 비율은 유지)
background-size: cover; (영역에 맞춰 전체 채움. 전체를 채우기 때문에 공백은 생기지 않으나 가려지는 이미지 부분 생김. 비율 유지)

*background 축약형
순서에 상관없이 작성 가능 하나 background-size작성시 반드시 포지션 사이즈 순서로 작성.
background: black url(../images/pattern.gif) no-repeat fixed 100% 0 / cover;(사이즈)


*background image 중첩
background-image: url(1), url(2);  -> box shadow처럼 , 로 중첩. 먼저 작성 된 이미지가 위에 옴.
background-repeat: no-repeat, repeat;  -> 첫번재이미지(맨위)는 반복X , 2번째이미지는 반복O.
background-attachment: fixed, scroll;   ->첫번째 이미지는 브라우저고정, 2번째 이미지는 스크롤에고정.

*background 중첩 축약형
background: 
url(../images/line.jpg) no-repeat fixed 50% 50%/ 700px, url(../images/more-leaves.png);


*선형그라디언트 linear-gradient
background-image: linear-gradient(rgb(254, 172, 225), skyblue); -> 위에서 아래로 첫번째색상,두번째색상 순으로
background-image: linear-gradient(to bottom, rgb(135, 135, 219), rgb(51, 51, 119); ->아래쪽으로
background-image: linear-gradient(to top, rgb(135, 135, 219), rgb(51, 51, 119) -> 위로;
background-image: linear-gradient(to right, rgb(135, 135, 219), rgb(51, 51, 119) -> 오른쪽으로
background-image: linear-gradient(pink, rgb(223, 152, 164), rgb(236, 159, 172), rgb(199, 114, 128); -> 4가지색상
background-image: linear-gradient(-125deg, rgb(234, 35, 68), pink);  -> 반대방향(deg=각도. 대각선)
background-image: linear-gradient(85deg, yellow 30%, green 80%);  ->방향, 1색상 위치%, 2색상 위치%
background-image: linear-gradient(transparent, blue);  -> 투명 ~ 색상
background-image: repeating-linear-gradient(orange 0, yellow 40px, orange 40px, yellow 80px) ;  ->반복
background-image: repeating-linear-gradient(45deg, pink 0, pink 10%, purple 10%, purple 20%); -> 스트라이프
0~10%범위까진 pink, 10~20%범위까진 purple. 이것을 반복
-범위를 px이아닌 %로 설정하면 브라우저 범위에 따라 늘어나고 줄어듦.


*원형그라디언트 radial-gradient
선형과 동일.
background-image: radial-gradient(blue 10%, yellow 70%);  ->안쪽 10%범위 blue, 바깥쪽 70%범위 yellow. background-image: radial-gradient(circle, rgb(122, 184, 220), rgb(74, 224, 181)); ->circle영역의 비율과 상관없이 정원의 형태로  언트 생성
background-image: radial-gradient(circle closest-side at 10% 80%, yellow, skyblue); ->띄어쓰기로 구분, closet-side at 10% 80% left에서 10%, top에서 80%만큼 이동해서 생성
background-image: repeating-radial-gradient(circle, red 0, yellow 20%); -> 원모양으로 반복 %는 번짐
background-image: repeating-radial-gradient(circle, red, red 40px, yellow 40px, yellow 80px); -> px로설정해서 안번짐


*웹폰트
@import 다른 문서나 외부 문서를 가져올 때 사용
@import url(경로)
웹폰트란 : 사용자의 폰트 설치와 상관없이 웹에서 항상 원하는 서체를 사용할 수 있게 하는 폰트
현재 웹폰트 사용: 사용자의 컴퓨터에 설치되지 않은 글꼴을 서버에 올려 놓은 후 해당 사이트에 접속하는 사용자의 컴퓨터에 다운되어 보여지게 함

설정값: 내가 웹폰트를 사용하기 위한
@font-face{
  font-family: '사용자 지정 이름';  (스타일 문서에 적용할 이름으로 내가 설정할 수 있음)
  src: local('로컬 서체 이름을 내가 설정한 이름 아님');
  url(경로) format(파일포맷);
  font-display:swap; 로딩상태에 따른 동작 설정
  swap:; FOUT방식. 로딩되는 동안 기본 서체로 보이고 완료되면 웹폰트 적용. 웹폰트 로딩 여부와 관계없이 항상 글자 보임
  auto:; 브라우저 기본값
  block:; FOIT방식. 웹폰트가 로딩되지 않으면 텍스트를 랜더링하지 않음. 로딩 완료 후 글자 보임
  font-style:normal;
  font-weight:400;


*em 단위 1
알파벳 M을 기준으로 만들어진 단위
부모의 "폰트 사이즈"를 기준으로 값 설정
 em은 바로 위의 부모 요소가 가지는 font-size값을 1em으로 설정해서 계산
브라우저의 기본 폰트 사이즈 : 16px

*rem
root, 즉 최상위 요소 (html)의 font-size를 기준으로 설정
rem 기준 최상위 root는 html 이다.
html기준 : 16px
1rem : 16px
body의 font-size를 변경해도 무조건 html 기준으로 1rem 적용.
html{font-size: 20px;} = 1rem : 20px


*viewport
뷰포트 기준 단위값: vw, vh
vw : viewport width
vh : viewport height
뷰포트의 가로 세로 값을 기준으로 사용하는 상대 단위 값
100분의 1 단위
상대 단위인 %는 부모를 기준으로 값을 정하지만, vw vh는 부모와는 상관없이 뷰포트(보여지는화면)를 기준으로 값을 정함.
스크롤바를 인식하지 못함.
width:100vw;
뷰포트 가로값 기준이나 브라우저 스크롤의 값은 인식하지 못하기 때문에 가로 스크롤이 생김


*컨텐츠가 없어도 브라우저의 높이 값을 인식시키는 방법
    1. html, body {height:100%} 이하 필요한 하위 요소까지 height:100% 적용
    2. position: absloute, fixed를 적용하면 height:100% 인식
    3. height:100vh 적용
    4. flex, grid

*iframe
영상첨부태그.
영상매체에서 원하는 영상 퍼가기 누르면 자동으로 복사 가능.
controls -> 하단 컨트롤바
autoplay-> 자동재생
loop-> 반복
mute-> 음소거(크롬 자동재생시 필수옵션)
0=부
1=여
<!-- "https://www.youtube.com/embed/videoID?옵션1&옵션2&loop=1&autoplay=1 -->
ex)<iframe src="https://www.youtube.com/embed/IbKdRZA8NOM?controls=0&loop=1&autoplay=1&mute=1" 


*가로세로 비율 aspect-ratio
(옛날방식 직접 계산법)
    유튜브  16 : 9 == 9 / 16 * 100 = 56.25%(padding-top에적용)
    일반 비디오 4 : 3 == 3 / 4 * 100 = 75%
    3 : 2 == 3 / 2 * 100 = 66.66666%
    8 : 5 == 5 / 8 * 100 = 62.5%
    1 : 1 ==  100%
(태그로 나옴)
aspect-ratio: 16 / 9 = 유튜브 비율
aspect-ratio: auto = 기본값
aspect-ratio: 1/1;  = 1:1
aspect-ratio: 3;  = 3:1 한자리 수의 경우 높이 비율 1이 생략된 것.
aspect-ratio: 0.5 = 1:2  잘안쓰임
aspect-ratio: 0.333 = 1:3
aspect-ratio: auto 1 / 1 = 기본값을 가지고 있는 경우 기본값 적용. 없는 경우 지정한 비율 적용.
{height: 300px;
 width: 300px;
aspect-ratio: 2/1;} = 가로,세로 값이 지정이 돼 있는 경우 적용 X
내용이 넘치는 경우 적용X. aspect-ratio가 적용이 되게 하려면 min-height:0을 써줌(넘치는컨텐츠는그냥넘치게됨)


*viewport meta태그
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
미디어쿼리 작성시 viewport값은 필수
모바일에서 웹페이지가 모바일에 맞게 보이려면 viewport값 필수
width=device-width; 해상도의 크기를 기기의 크기와 맞춤
initial-scale=1.0; 기본 크기
maximum-scale=1.0; 확대 안됨
minimum-scale=1.0; 축소 안됨
user-scalable=no; 사용자의 확대 축소 안됨


* flex
display: flex
    뷰포트나 요소의 크기가 동적으로 변할 때 사용
    상속되지 않음
    부모 박스(flex-container<class명>)와 자식 아이템(flex-item<class명>)의 개념으로 구성
    주축(main axis)와 교차축(cross axis)이 존재하며 이 축을 기준으로 방향을 정함
    부모 박스의 높이값 안에서 적용됨.
    교차축의 기본은 stretch
    
    flex-container에 들어가는 특성: flex-direction, flex-wrap, justify-content, align-content, gap...
    flex-item에 들어가는 특성: align-self, flex, flex-grow, flex-shrink, flex-basis, order ...

-플렉스 아이템들의 가로 세로 정렬 기준 설정 (flex-direction)
 flex-direction: row;  기본값. 주축은 가로(왼 -> 오른) 교차축은 세로(위 -> 아래)
 flex-direction:column;  주축이 세로. 아이템들이 세로로 바뀜 (위 -> 아래)  교차축은 (왼 -> 오른)
 flex-direction: row-reverse; 주축은 역가로(오른 -> 왼)
 flex-direction: column-reverse; 주축은 역세로(아래 ->위)
 
-플렉스 줄바꿈 flex-wrap
 flex-wrap: nowrap; 기본값. 플렉스 아이템 한줄 배치(줄바꾸지않음)
 flex-wrap: wrap;  줄바꿈. 
 flex-wrap: wrap-reverse; 역방향 줄바꿈

-flex-flow
flex-direction, flex-wrap을 한번에 작성하고자 할 때 사용. 순서 상관없음
flex-flow: row wrap;
flex-flow: wrap;  생략된 값은 기본값 적용.

-아이템의 행과 열사이의 간격 gap
gap:0; 기본값. 0
gap:10% 5%; (row-gap, column-gap)
gap:10%; (row-gap, column-gap 둘다)
row-gap:
column-gap:

-주축 기준 플렉스 아이템 정렬 
 justify-content: flex-start; 기본값. 주축의 시작점 기준 정렬
 justify-content: flex-end; 주축의 끝점 기준 정렬
 justify-content: center;  주축 기준 중앙 정렬
 justify-content: space-around; 주축 기준으로 여백 포함 동일한 간격으로 정렬
 justify-content: space-between; 주축 기준으로 양끝에 맞춰 아이템을 정렬하고 여백은 동일한 값으로 부여하여 정렬
 justify-content: space-evenly;  around+evenly 주축 기준으로 아이템과 여백을 다 동일하게 정렬

-교차축 기준 플렉스 아이템 정렬
align-items: stretch; 기본값. 아이템 높이값이 없어도 컨테이너의 높이값만큼 아이템 확장 정렬
align-items: flex-start; 교차축 기준 시작점부터 정렬
align-items: flex-end; 교차축 기준 끝점부터 정렬
align-items: center; 교차축 기준 중앙 정렬

-교차축 기준 여러 아이템을 하나의 덩어리로 취급해 정렬 align-content
align-content: stretch; 기본값. 높이값이 지정되어 있으면 적용되지 않음.
align-content: flex-start;
align-content: flex-end;
align-content: space-around;         교차축 기준 justify와 동일
align-content: space-between;
align-content: space-evenly;

부모 요소에 플렉스 적용시 자식 아이템은 margin을 통해 개별적으로 위치 지정 가능. 더 섬세하게 조정 가능(주축의개별배치는 없지만 마진으로 가능)
margin-left: auto; 여백이 왼쪽으로 들어가기 때문에 아이템은 오른쪽 배치 
margin-right: auto; 여백이 오른쪽으로 들어가기 때문에 아이템은 왼쪽 배치 
margin-bottom: auto; 여백이 아래쪽으로 들어가기 때문에 아이템은 위쪽 배치 
margin-top: auto; 여백이 위쪽으로 들어가기 때문에 아이템은 아래쪽 배치

-align-items 특성의 개별 배치 align-self(교차축기준)
자식인 플렉스 아이템에 적용. 
align-self: flex-start   축의 시작점 
align-self: flex-end;   축의 끝점 
align-self: center;     축의 중앙
align-self: baseline;   글자라인에 맞춤(자주안쓰임)
align-self:stretch;      컨테이너 높이값 만큼 확장
 

*대메뉴 소메뉴 적용법
-대메뉴 안 소메뉴만 보이게 할 때
  대메뉴클래스값, 소메뉴클래스값 따로 부여

 .대메뉴, .소메뉴{display:none;}
 .대메뉴 > li:hover > .소메뉴{display:block;}
/* 각 대메뉴에 마우스를 올리면, 해당 대메뉴의 소메뉴가 나타남 */

-대메뉴 안 소메뉴 전체를 보이게 할 때
 .대메뉴, .소메뉴{display:none;}
 .대메뉴:hover .소메뉴{display:block;}
/* 대메뉴 아무데나 마우스를 올리면, 소메뉴 전체가 한번에 나타남*/


*inline-flex
인라인성격으로 flex 적용

<<flex-item css 특성 종류>>
    ㄴ order, flex-grow, flex-shrink, flex-basis, flex ...
    
     flex-grow: 0; 숫자가 클수록 더 큰 영역을 가짐. 가변값이 아니거나 0인 경우 적용되지 않음.
     flex-shrink: 1; 숫자가 클수록 더 큰 영역 감소. 가변값이 아니거나 0인 경우 적용되지 않음.
     flex-basis: auto; 기본 가로 값 설정. auto인 경우 width, height 등의 특성을 가로 설정이 가능하나 단위값이 주어진 경우 설정 안됨.
     flex: 증가 비율(flex-grow) 감소비율(flex-shrink) 기준비율(flex-basis)
     flex: 0 1 auto; 기본값


*flexitem order
flex-item에 적용되는 특성으로 아이템 배치 순서 설정
order:1; (마지막 item 뒤에서 부터 1번째로 정렬)

*flexItem: flex-grow플렉스 아이템의 증가 비율 제어
flex-grow:0; 기본값. 증가하지 않음. 플렉스 아이템이 가지고 있는 기본값 그대로 유지(강제로 컨테이너를 채우지 않음)
flex-grow: 1; 각 아이템들이 1의 비율로 증가하여 알아서 똑같은 비율로 컨테이너를 채움(width80일때 item이4개라면 각 20의 비율)
flex-grow:1; flex-gorw:2; 1:1:1:2 숫자가 클 수록 차지하는 비율이 큼.
width:300px; flex-grow:1; flex-gorw:2; 고정값을 뺀 나머지 계산 후 비율로 나눔(width값을 지정하면 전체비율에 속하지않음)
전체 width - 300px = 나눌값

*flexItem: flex-shrink 감소 비율
숫자가 클수록 감소 폭 커짐. 숫자가 클수록 아이템의 크기는 더 작아짐.
flex-shrink:1; 기본값. 아이템이 컨테이너 width 보다 넘쳐도 아이템이 컨테이너를 넘기지 않음. 
flex-shrink:0; item의 width값 그대로 적용. 아이템 크기 유지. 즉 넘치는 경우 컨테이너를 넘김. 

*flex-itme: flex-basis 기준 비율
flex-basis auto; 기본값. 아이템 컨텐츠 크기에 맞춰 grow 비율 설정
flex-basis: 0; 플렉스 아이템의 컨텐츠를 제외한 영역을 기준으로 grow와 shrink설정
flex-basis: 300px; px로 설정 했을 때 만약 기본값으로 flex-shrink:1;이 미리 설정이 되어 있으면 컨테이너를 넘기지 못함.

*grow, shrink, basis의 축약형 flex
flex: 0 1 auto;  = flex-grow:0; / flex-shrink:1; / flex-basis:auto 순서
-----참고-----
flex: 1 1 0; = flex:1 1; 로 사용 가능.(0생략)
flex: 2 1 100px; = flex:2 100px; 로 사용가능. 
-생략시 기본값이 적용됨.
-flex-basis 값 생략은 auto;가 아닌 0을 의미.
-flex:none; = flex: 0 0 auto;


*컨텐츠 스르륵 움직임 transition
-움직임 속성
trnasition-property: width;

-움직임 진행시간
transition-duration:1s;

-움직임 지연
transition-delay

  .box:hover{
      width:500px;
      height: 500px;
      font-weight: bold;
      font-size:2rem;
      background-color: cadetblue;}
=가로값을 1초동안 위 조건으로 스르륵 늘어나게 만들겠다.

 transition-property: width, height, background-color, font-size, font-weight;
 transition-duration:    1s,         3s,                1.5s,                       3s,                 1s;
   ,로 구분하여 각각의 초단위 설정 가능.

transition-delay: 0; 기본값.
transition-delay: 1s; 1초 기다렸다가 진행됨.


*움직임 속도 제어 transition-timing-function
 transition-timing-function: linear;   동일한 속도로 진행
 transition-timing-function:ease;     기본값. 서서히 증가하다 끝에서 느려짐
 transition-timing-function: ease-in;   서서히 시작하다 끝날 때 빨라짐
 transition-timing-function: ease-out;   빠르게 시작하고 끝날 때 느려짐
 transition-timing-function: ease-in-out;   서서히 시작하다 빨라지고 끝날 때 느려짐
 transition-timing-function: cubic-bezier();   사용자 정의 움직임
 *https://easings.net/ko Easing
   https://cubic-bezier.com  
   함수시트 사이트 * -> cubic bezier 값 적용 가능


*transition 축약형
값의 순서에 상관없이 작성 가능. 첫번째 나오는 숫자는 시간, 두번째 숫자는 대기 시간
transition: all 1s 1s ease-in-out ;
   -> transition-property: all;
        transition-duration: 1s;
        transition-delay: 1s;
        transition-timing-function: ease-in-out;
숫자가 1개만 있으면 진행 시간을 의미
 ->transition: 1s ease;


*이미지 변형 transform 
 (transition 시간을 설정해주어야 스르륵 적용됨)

1. transform : scale() 크기
transform : scale(2);  ->배수의 값으로 단위값 없음(2배로커짐)
transform : scale(1.5);  ->배수의 값으로 단위값 없음(1.5배로커짐)
transform: scale(1.2, 0.5);  -> x축 1.2배,  y축 0.5배
transform: scaleX(1.7);  ->x축만 1.7배
transform: scaleY(1.7);  ->y축만 1.7배

2. transform : rotate() 회전
transform : rotate(45deg);  ->45도 시계 방향으로 회전
transform: rotate(-360deg);  ->360도 반시계 방향으로 회전
transform: rotatex(45deg);  -> x축
transform: rotatey(45deg);  -> y축

3. transform : Skew() 기울기
transform: skew(45deg);  ->45도 시계방향으로 기울기
transform: skew(-45deg);  ->45도 반시계방향으로 기울기
transform: skew(15deg, 15deg);  -> x축 y축
transform: skewX();  -> x축
transform: skewY();  -> y축

4. transform : translate() 이동
transform: translate(50%);  -> 한자리수 : x축 오른쪽으로 이동
transform: translateX(250px);  -> x축 이동
translateY(250px);  -> y축 아래로 이동
transform: translate(50%, 50%)  -> 원래 있던 자리에서 50% 만큼 x,y축 이동
음수값은 반대 방향

*이동 가능한 css 특성*
  ㄴmargin: 여백을 만들어서 이동. 레이아웃에 영향을 줌. 옆에 다른 요소가 있으면 밀림.
  ㄴposition: 독자적인 흐름을 갖는 경우
  ㄴtranslate(): 자기 자신을 기준으로 이동

5. transforrm-origin 기준축
transform-origin: 50%;  -> 기본값 50% 50%
transform-origin: center center;   -> 기본값
transform-origin: 20px 20px;  -> 원래자리에서 x축 20px, y축 20px 만큼 이동
transform-origin: 100% 100%;  -> right bottom
transform: translate(-50%, -50%);  ->중앙정렬

6. transform 축약형
transform: scale(0.5);
transform:rotate(360deg);
   -> transform은 우선순위가 적용되기 때문에 같은 특성값 중 맨 마지막 명령이 적용됨.
transform: scale(0.5) rotate(360deg); 
   -> 여러개의 값 한번에 적용 시 띄어쓰기로 구분. 순서에 따라 결과 값이 달라 질 수 있음.

(display:none; 은 브라우저 영역에서 사라지며 코드창에서만 확인 됨. 레이아웃에 영향을 줌. transition의 영향을 받지 않음.
 opacity:0; 은 사용자 눈에만 보이지 않음. 영역은 그대로 남음. 투명도 조절 가능. transition의 영향을 받음.)


*svg파일 적용법
svg이미지는 코드로 이미지를 형상한것.
그 코드를 복사해서 css에 붙여넣으면 적용됨.
svg 색상 바꾸는법 : fill:rgba(0,0,0,.5)  fill을사용한다.


* :is(.box2, .box3, .box4) h3
      = .box2 h3, .box3 h3, .box4의 h3
          :is(선택자1, 선택자2 ...) 여러 선택자 선정
          div:not(.box1) 인수의 값이 .box1을 제외한 div 요소 

*포지션 중앙정렬 정리
- 포지션이 적용되어 있지 않으며 요소의 값은 정의 되었을 때
   margin:5vh auto;  /* box1의 높이값 - h3의 높이값 /2  */

-포지션이 적용되어 있을 때
1. 
    top:50%; left:50%;
    margin-top:-5vh;
    margin-left:-25%;
= 가로 세로 값이 정의 되었을 때 가능. 요소가 가진 값의 반을 같은 방향의 마진으로 마이너스로 처리
2.
     top:0; right:0; bottom:0; left:0;
     margin: auto;
=가로 세로 값이 정의 되었을 때 가능
3.
    top:50%; left:50%;
    transform:  translate(-50%, -50%);
=현재 가장 많이 사용 되는 포지션 중앙정렬 방법. 가로세로 값이 정의되어 있지 않아도 가능.
 

*transform_perspective(); 원근감
한 선택자에 혼자 쓰이지 않음. 
다른 transform 값과 같이 사용할 시 원근감(z축) 적용
원근감을 주고자 하는 대상에 직접 적용
transform: perspective(200px) translateX(50px);


*perspective(); 원근감
원근감을 주고자 하는 대상의 부모에 적용. 
여러 자식 요소를 일괄적으로 제어하고자 할 때 사용.
자식 요소를 하나의 덩어리로 보고 원근값 일괄 적용.

perspective-origin
   -부모에게 적용(자식이 원근값을 가지며 숫자가 적을수록 원근감이 가까워지기 때문에 심한 왜곡이 생김. 숫자가 크면 원근감이 멀어지기 때문에 왜곡이 심하지 않음)
  부모요소태그{ perspective: 300px;}
   -원근감 시선의 기준 
    자식요소태그{perspective-origin: center;(기본값)}
    자식요소태그{perspective-origin: bottom;}
    자식요소태그{perspective-origin: top;}
    자식요소태그{perspective-origin: left;}
    자식요소태그{perspective-origin: right;}


*transformstyle 3d 속성 상속
3D 변환 요소의 자식도 3D값을 사용할지 결정.
transform-style : flat; 기본값
transform-style : preserve-3d; 3D 값을 사용

 @keyframes identifier {
*backface-visibility
backface-visibility: hidden; (뒷면 숨김)
backface-visibility: visible; (기본값. 뒷면 숨기지 않음)


*스스로 움직이는 애니메이션 
animation-name: ani_1; (애니메이션 이름. 키프레임에 부여한 이름)
animation-duration: 1s; (애니메이션 진행시간)
animation-delay: 0.5s; (애니메이션 대기시간)
animation-timing-function: linear; (애니메이션 움직임 스타일)
 animation-iteration-count: 3; (애니메이션 반복 횟수. 

 @keyframes identifier {사용자 정의 이름}  -> 작성해주고 애니메이션 이름에 똑같이 입력. 작성 위치는 상관 없음.
       @keyframes ani_1(사용자 정의 이름){
         from{width:400px; height: 400px;}(움직임시작)
         to{width:600px; height: 600px;  background-color: #ddd;}(움직임 끝) }
  =시작 400x400 에서 끝 600x600 으로 변하고 배경색 변함.
from과 to는 숫자로도 표기 가능.  0% ~ 100% ↓이런식으로
    30%, 70% {transform: rotate(180deg); }
   100% {transform: rotate(-180deg);}

animation-fill-mode: backwards; (기본값. 애니메이션 끝난 후 출발점으로 돌아옴)
animation-fill-mode: forwards;  (끝난 후 도착점에 그대로 있음)
animation-direction: normal; (기본값)
animation-direction: reverse; (역방향)
animation-direction: alternate; (순방향 진행 후 역방향 진행 1>2>3>2>1)
animation-direction: alternate-reverse; (역방향 진행 후 순방향 진행 3>2>1>2>3)
animation-play-state: paused; (일시 멈춤 running 실행)

animaition : 축약형(순서에 상관없이 띄어쓰기로 구분. 두번째 나오는 s는 대기시간으로 생략 가능)
 animation: name 1s 0.5s 3 cubic-bezier(0.075, 0.82, 0.165, 1) alternate forwards; }


*CSS 변수 variable
사용자 지정 속성
사용자가 정의하는 속성과 값으로 재활용 할 수 있는 임의의 값
공통으로 사용되는 값에 css 변수를 설정하여 코드의 반복 사용을 줄임

전역 설정
:root { --variable-name: value; }
:root { --variable: value; }

지역 설정
dt { --variable-name: value; }
지정된 요소와 하위 요소에서만 적용

사용
property: var(--variable-name);
property: var(--variable);

  <style>
 /* 전역 선언 */
   :root{
    /* 설정시 사용자 지정 이름 */
    --color: blue;
    --fontColor: red;
    --fontsize:1.2rem;
    --bg: url(../images/fireworks.png);
   }

   /* 전역 선언 적용 */
   h1{
    color: var(--fontColor);  -> html문서 전체의 h1은 모두 --fontColor(red)를 적용시킨다는 뜻.
    background-color: var(--color)  -> 배경색은 --color(blue)를 적용시킨다는 뜻.
   }

   /* 지역 선언 */
   ul{
    /* 태그 안에서 변수 선언 하는 경우 이 태그 하위까지만 적용 
         전역과 지역이 중복되는 경우 지역이 우선*/
    --color: orange;
    --font-size: 1.1rem;
    background-color:  var(--color);
   } -> ul의 하위 li만 적용 됨. dt나 td같은 다른 하위는 적용 안됨.
  </style>


*kakao map 적용
https://apis.map.kakao.com/
카카오 지도 api 사이트 접속
https://apis.map.kakao.com/web/guide/


*grid

display:grid;
column:분단
row:줄

display-template-columns : 1fr 2fr 1fr;
 - item의 크기들이 부모요소 가로전체의 1:2:1의 크기를 가짐.

display-template-rows : 1fr 2fr 1fr;
 - item의 크기들이 부모요소 세로전체의 1:2:1의 크기를 가짐.

display-template-columns: repeat(5, 1fr);
 -repeat은 1fr 1fr 1fr 1fr 1fr의 축약형. 5분단이 1비율의 크기를 가짐.

display-template-rows: repeat(3, 1fr);
 -repeat은 1fr 1fr 1fr 의 축약형. 3줄이 1비율의 크기를 가짐.

grid-auto-rows,columns :20%;
 -행,열이 몇개인지 모르겠지만 전부 부모요소크기의 20%로 유지

grid-auto-rows,columns: minmax(20%, auto);
 -안의 컨텐츠가 없을땐 20%로 유지하되, 컨텐츠가 넘치면 넘치는만큼 전부 보여짐

grid-gap; : 20px or gap: 20px;
 -그리드아이템 사이 공간

grid-column,row-start: 1;
grid-column,row-end:3;
 -그리드 아이템이 4개라면 각 모서리 숫자가 5개인데 start,end로 그 수만큼 합칠 수 있다.
  1번모서리부터 3번모서리까지 합쳐짐.
반대편 맨 마지막은은 -1, -2, -3

축약형 : grid-column : 1/3;
           grid-row : 3/4;

grid-column: 2 / span3;
 - 셀의 숫자를 세기 힘들 때 span사용. 2번부터 2번뒤~3개셀까지 합침.
 =grid-column-start: 2; / grid-column-end: 5; 와 같음.

grid-column : 2 / -1;
 -2번부터 제일 끝까지 합침

container영역에서 
grid-template-areas:
'a a a'
'b c c'
'b d g'
'e f g'
템플릿을 설정 해 놓고 
각 item에
grid-area: a;
grid-area: b;
이런식으로 값을 주면 설정한 대로 합쳐짐.
여백은 . 으로 작성 함.